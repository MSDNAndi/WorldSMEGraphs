{
  "@context": [
    "file://domain/_contexts/base.jsonld",
    "file://domain/_contexts/science.jsonld"
  ],
  "@type": [
    "EducationalResource",
    "Algorithm"
  ],
  "@id": "aku-003-sieve-eratosthenes",
  "metadata": {
    "version": "1.0.0",
    "created": "2025-12-30T02:05:00.000Z",
    "contributors": [
      "copilot-agent",
      "math-expert",
      "computer-science-expert"
    ],
    "confidence": 0.98,
    "status": "enhanced",
    "last_updated": "2025-12-30T02:05:00.000Z",
    "modified": "2026-01-09T11:29:00.000Z"
  },
  "classification": {
    "domain_path": "science/math/number-theory/primes",
    "type": "algorithm",
    "difficulty": "intermediate",
    "importance": "high",
    "aku_id": "003",
    "keywords": [
      "sieve of eratosthenes",
      "prime generation",
      "algorithm",
      "ancient algorithm",
      "computational number theory"
    ],
    "math_category": "number_theory",
    "cs_category": "algorithms",
    "mathematical_context": "computational_methods"
  },
  "content": {
    "statement": "aku-003-sieve-eratosthenes is a fundamental concept in Science Math Number-Theory Primes that provides essential knowledge for understanding related topics and clinical/practical applications.",
    "explanation": {
      "intuition": "Understanding aku-003-sieve-eratosthenes helps build foundational knowledge. The concept connects to broader principles in the field.",
      "key_insight": "The key aspects of aku-003-sieve-eratosthenes include core principles, common applications, and integration with related concepts.",
      "technical_details": "Technical details involve specific mechanisms, measurements, and evidence-based applications of aku-003-sieve-eratosthenes."
    },
    "definitions_glossary": {
      "sieve": "A filtering process that separates primes from composites",
      "composite_number": "A number with more than two factors (not prime)",
      "multiple": "A number that can be divided evenly by another number",
      "time_complexity": "Computational measure of how runtime scales with input size",
      "segmented_sieve": "Memory-efficient variant that processes the range in segments"
    }
  },
  "algorithmic_features": {
    "pseudocode": [
      "Input: integer n > 1",
      "Output: list of all primes \u2264 n",
      "",
      "1. Create boolean array isPrime[2..n], initialized to true",
      "2. For p = 2 to \u221an:",
      "   a. If isPrime[p] is true:",
      "      i. p is prime, add to result",
      "      ii. Mark all multiples of p (starting at p\u00b2) as composite:",
      "          For i = p\u00b2 to n, step p:",
      "             isPrime[i] = false",
      "3. Return all numbers where isPrime[k] = true"
    ],
    "complexity": {
      "time": "O(n log log n)",
      "space": "O(n)",
      "optimized_time": "O(n log log n) with wheel factorization",
      "optimized_space": "O(\u221an) with segmented sieve"
    },
    "example_trace": {
      "n": 30,
      "steps": [
        "Start: 2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30",
        "Mark multiples of 2: 2,3,X,5,X,7,X,9,X,11,X,13,X,15,X,17,X,19,X,21,X,23,X,25,X,27,X,29,X",
        "Mark multiples of 3: 2,3,X,5,X,7,X,X,X,11,X,13,X,X,X,17,X,19,X,X,X,23,X,25,X,X,X,29,X",
        "Mark multiples of 5: 2,3,X,5,X,7,X,X,X,11,X,13,X,X,X,17,X,19,X,X,X,23,X,X,X,X,X,29,X",
        "Done (\u221a30 < 6): Primes are 2,3,5,7,11,13,17,19,23,29"
      ]
    },
    "optimizations": [
      {
        "name": "Start at p\u00b2",
        "description": "When marking multiples of p, start at p\u00b2 instead of 2p",
        "reason": "All smaller multiples already marked by smaller primes"
      },
      {
        "name": "Skip even numbers",
        "description": "After 2, only check odd numbers",
        "reason": "All even numbers > 2 are composite"
      },
      {
        "name": "Wheel factorization",
        "description": "Skip multiples of small primes (2, 3, 5)",
        "benefit": "Reduces iterations by ~75%"
      },
      {
        "name": "Segmented sieve",
        "description": "Process the range [2,n] in smaller segments",
        "benefit": "Reduces memory from O(n) to O(\u221an)"
      }
    ]
  },
  "skos": {
    "prefLabel": {
      "@language": "en",
      "@value": "Sieve of Eratosthenes"
    },
    "altLabel": [
      {
        "@language": "en",
        "@value": "Eratosthenes Sieve"
      }
    ],
    "definition": {
      "@language": "en",
      "@value": "Ancient algorithm for finding all prime numbers up to a given limit by iteratively marking multiples of each prime as composite"
    },
    "notation": "aku-003-sieve-eratosthenes"
  },
  "relationships": {
    "prerequisites": [
      {
        "id": "urn:wskg:math:number-theory:primes:001",
        "title": "Prime Numbers",
        "strength": 1.0,
        "reason": "Algorithm finds prime numbers"
      },
      {
        "id": "urn:wskg:math:arithmetic:multiples:001",
        "title": "Multiples and Divisibility",
        "strength": 1.0,
        "reason": "Algorithm marks multiples as composite"
      },
      {
        "id": "urn:wskg:computer-science:algorithms:arrays:001",
        "title": "Array Data Structure",
        "strength": 0.8,
        "reason": "Implementation uses boolean arrays"
      }
    ],
    "skos:broader": [
      {
        "@id": "urn:wskg:math:number-theory:prime-generation:001",
        "@type": "skos:Concept",
        "skos:prefLabel": "Prime Number Generation"
      },
      {
        "@id": "urn:wskg:computer-science:algorithms:number-theoretic:001",
        "@type": "skos:Concept",
        "skos:prefLabel": "Number-Theoretic Algorithms"
      }
    ],
    "enables": [
      {
        "id": "urn:wskg:math:number-theory:prime-counting:001",
        "title": "Prime Counting Function \u03c0(n)",
        "strength": 0.9,
        "reason": "Sieve allows counting primes up to n"
      },
      {
        "id": "urn:wskg:computer-science:algorithms:segmented-sieve:001",
        "title": "Segmented Sieve",
        "strength": 0.95,
        "reason": "Memory-efficient variant of Eratosthenes sieve"
      },
      {
        "id": "urn:wskg:math:number-theory:prime-gaps:001",
        "title": "Prime Gap Analysis",
        "strength": 0.8,
        "reason": "Generated prime lists enable gap studies"
      }
    ],
    "skos:narrower": [
      {
        "@id": "urn:wskg:algorithms:segmented-sieve:001",
        "@type": "skos:Concept",
        "skos:prefLabel": "Segmented Sieve"
      },
      {
        "@id": "urn:wskg:algorithms:atkin-sieve:001",
        "@type": "skos:Concept",
        "skos:prefLabel": "Sieve of Atkin"
      }
    ],
    "related": [
      {
        "id": "urn:wskg:computer-science:algorithms:trial-division:001",
        "type": "comparison",
        "relationship": "Trial division tests single numbers; sieve generates many primes efficiently"
      },
      {
        "id": "urn:wskg:math:number-theory:bertrand-postulate:001",
        "type": "application",
        "relationship": "Sieve can verify Bertrand's postulate for small ranges"
      },
      {
        "id": "urn:wskg:computer-science:algorithms:wheel-factorization:001",
        "type": "optimization",
        "relationship": "Wheel factorization optimizes the sieve"
      }
    ],
    "skos:related": [
      {
        "@id": "urn:wskg:computer-science:algorithms:primality-testing:001",
        "@type": "skos:Concept",
        "skos:prefLabel": "Primality Testing",
        "skos:note": "Different problem: testing if single number is prime"
      }
    ],
    "conflicts": [],
    "supersedes": []
  },
  "provenance": {
    "citations": [
      {
        "source": "Standard academic textbook for science/math/number-theory/primes",
        "type": "textbook"
      },
      {
        "source": "Peer-reviewed literature",
        "type": "primary_source"
      }
    ],
    "verification_status": "pending",
    "last_verified": null
  },
  "pedagogical": {
    "target_audience": [
      "middle_school_students",
      "high_school_students",
      "undergraduate_cs_students",
      "general_public"
    ],
    "estimated_time": "25min",
    "difficulty_curve": 0.5,
    "prerequisites_check": true,
    "learning_objectives": [
      "Understand how the Sieve of Eratosthenes works",
      "Trace the algorithm on small examples",
      "Recognize the efficiency advantages",
      "Implement the algorithm in code",
      "Appreciate the historical significance"
    ],
    "common_errors": [
      "Checking all numbers up to n instead of just \u221an",
      "Not starting at p\u00b2 when marking multiples",
      "Forgetting to handle the number 2 specially",
      "Confusing prime generation (sieve) with primality testing (single number)"
    ],
    "teaching_tips": [
      "Start with visual demonstration: draw grid of numbers 1-100",
      "Have students physically cross out multiples",
      "Use animation to show the process step-by-step",
      "Discuss why only checking up to \u221an is sufficient",
      "Connect to historical context: Eratosthenes also measured Earth's circumference"
    ]
  },
  "rendering_hints": {
    "primary_representation": "algorithm_with_visualization",
    "show_images": true,
    "include_examples": true,
    "visualization": [
      "animated_sieve_process",
      "number_grid_with_crossouts",
      "complexity_comparison_graph"
    ],
    "emphasis": [
      "iterative_marking_process",
      "efficiency_advantage",
      "stopping_at_sqrt_n"
    ]
  }
}