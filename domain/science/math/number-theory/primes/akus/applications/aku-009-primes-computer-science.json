{
  "@context": [
    "file://domain/_contexts/base.jsonld",
    "file://domain/_contexts/science.jsonld"
  ],
  "@type": [
    "EducationalResource",
    "CrossDomainConnection"
  ],
  "@id": "aku-009-primes-computer-science",
  "metadata": {
    "version": "1.0.0",
    "created": "2025-12-30T02:28:00.000Z",
    "contributors": [
      "copilot-agent",
      "math-expert",
      "computer-science-expert"
    ],
    "confidence": 0.93,
    "status": "validated",
    "last_updated": "2025-12-30T02:28:00.000Z"
  },
  "classification": {
    "domain_path": "science/math/number-theory/primes",
    "type": "application",
    "difficulty": "intermediate",
    "importance": "high",
    "aku_id": "009",
    "keywords": [
      "prime numbers",
      "hash tables",
      "hash functions",
      "computer science",
      "data structures",
      "algorithms"
    ],
    "math_category": "number_theory",
    "cs_category": "algorithms_and_data_structures",
    "mathematical_context": "applications",
    "cross_domain_connection": "math_to_computer_science"
  },
  "content": {
    "statement": {
      "text": "Prime numbers play crucial roles in computer science beyond cryptography. Hash table sizes are often chosen to be prime to minimize collisions and ensure good distribution. Prime numbers appear in random number generators, bloom filters, data structure design, and algorithm analysis. Their mathematical properties of coprimality and unique factorization make them essential tools for algorithmic efficiency.",
      "formal": "Hash function h(k) = k mod m performs best when m is prime. Collisions minimized when gcd(k₁-k₂, m) = 1 for distinct keys. Primes ensure uniform distribution in open addressing and chaining."
    },
    "explanation": {
      "intuition": "Think of organizing library books. If you have 100 shelves and use shelf = (book_id mod 100), books might clump together. But with 101 shelves (prime), books spread more evenly because 101 shares no factors with most book IDs. This 'mathematical spreading' property of primes reduces collisions in data storage.",
      "key_insight": "Primes are 'maximally coprime'—they share no factors with most other numbers. This property ensures uniform distribution in modular arithmetic operations. When hash table size is composite (like 100 = 2² × 5²), many keys map to same slots due to common factors. Prime sizes eliminate this systematic bias.",
      "technical_details": "In hash tables with size m and hash function h(k) = k mod m: if m is composite with factor d, all multiples of d collide at positions divisible by d, creating clustering. Prime m ensures no such systematic collisions. For open addressing with linear probing, prime table sizes guarantee full exploration of all slots. In double hashing, both table size and secondary hash must be coprime for complete coverage—easiest achieved with prime table size.",
      "common_misconceptions": [
        "Only cryptography uses primes in CS—they're used throughout data structures and algorithms",
        "Any table size works fine—prime sizes significantly reduce collision rates",
        "Primes only matter for integers—they affect performance even with hashed strings/objects",
        "Bigger tables always better—prime sizing can outperform larger composite sizes"
      ]
    },
    "definitions_glossary": {
      "hash_table": "Data structure mapping keys to values via hash function",
      "hash_function": "Function converting key to array index",
      "collision": "When different keys hash to same index",
      "load_factor": "Ratio of elements to table size (α = n/m)",
      "open_addressing": "Collision resolution by probing for next available slot",
      "separate_chaining": "Collision resolution using linked lists at each slot",
      "coprime": "Two integers sharing no common factors except 1"
    }
  },
  "computer_science_features": {
    "hash_table_applications": [
      {
        "structure": "Hash table with prime size",
        "benefit": "Uniform key distribution",
        "example": "Table size 1009 (prime) vs 1000 (composite)",
        "collision_reduction": "Up to 30% fewer collisions"
      },
      {
        "structure": "Open addressing with linear probing",
        "benefit": "Guaranteed full table exploration",
        "requirement": "Table size must be prime",
        "rationale": "Ensures all slots visited before repetition"
      },
      {
        "structure": "Double hashing",
        "benefit": "Pseudo-random probing sequence",
        "requirement": "gcd(step_size, table_size) = 1",
        "solution": "Use prime table size"
      }
    ],
    "other_cs_applications": [
      {
        "application": "Random number generators",
        "use": "Linear congruential generators use prime moduli",
        "formula": "X_{n+1} = (aX_n + c) mod m, m prime",
        "benefit": "Maximal period length"
      },
      {
        "application": "Bloom filters",
        "use": "Array size often prime",
        "benefit": "Better distribution of hash values",
        "note": "Reduces false positive rate"
      },
      {
        "application": "Skip lists",
        "use": "Prime-based level promotion",
        "benefit": "Better randomization properties"
      },
      {
        "application": "Rabin-Karp string matching",
        "use": "Rolling hash with prime modulus",
        "benefit": "Efficient pattern matching",
        "complexity": "O(n+m) expected time"
      },
      {
        "application": "Checksums and error detection",
        "use": "Prime moduli in polynomial hashing",
        "benefit": "Detects errors with high probability"
      }
    ],
    "implementation_example": {
      "language": "Python",
      "code": [
        "# Prime-sized hash table",
        "TABLE_SIZE = 1009  # Prime number",
        "",
        "def hash_function(key):",
        "    return hash(key) % TABLE_SIZE",
        "",
        "# Double hashing with coprime step",
        "def double_hash(key, attempt):",
        "    h1 = hash(key) % TABLE_SIZE",
        "    h2 = 1 + (hash(key) % (TABLE_SIZE - 2))  # Ensure coprime",
        "    return (h1 + attempt * h2) % TABLE_SIZE"
      ]
    },
    "performance_analysis": {
      "collision_comparison": [
        {
          "table_size": 1000,
          "type": "composite (2³×5³)",
          "collision_rate": "high",
          "clustering": "significant"
        },
        {
          "table_size": 1009,
          "type": "prime",
          "collision_rate": "low",
          "clustering": "minimal"
        }
      ],
      "load_factor_impact": "With prime table size, performance degrades gracefully even at α > 0.7"
    }
  },
  "skos": {
    "prefLabel": {
      "@language": "en",
      "@value": "Prime Numbers in Computer Science"
    },
    "altLabel": [
      {
        "@language": "en",
        "@value": "Primes in Data Structures"
      },
      {
        "@language": "en",
        "@value": "Hash Table Prime Sizing"
      }
    ],
    "definition": {
      "@language": "en",
      "@value": "Application of prime numbers to optimize data structures and algorithms through coprimality and uniform distribution properties"
    },
    "notation": "aku-009-primes-computer-science"
  },
  "relationships": {
    "prerequisites": [
      {
        "id": "urn:wskg:math:number-theory:primes:001",
        "title": "Prime Numbers",
        "strength": 1.0,
        "reason": "CS applications use prime properties"
      },
      {
        "id": "urn:wskg:math:number-theory:coprimality:001",
        "title": "Coprimality",
        "strength": 0.95,
        "reason": "Coprimality ensures uniform distribution"
      },
      {
        "id": "urn:wskg:computer-science:data-structures:hash-tables:001",
        "title": "Hash Tables",
        "strength": 0.9,
        "reason": "Primary application domain"
      },
      {
        "id": "urn:wskg:math:modular-arithmetic:001",
        "title": "Modular Arithmetic",
        "strength": 0.9,
        "reason": "Hash functions use mod operation"
      }
    ],
    "skos:broader": [
      {
        "@id": "urn:wskg:computer-science:data-structures:001",
        "@type": "skos:Concept",
        "skos:prefLabel": "Data Structures"
      },
      {
        "@id": "urn:wskg:math:applications:computer-science:001",
        "@type": "skos:Concept",
        "skos:prefLabel": "Mathematical Applications in CS"
      }
    ],
    "enables": [
      {
        "id": "urn:wskg:computer-science:hash-table-optimization:001",
        "title": "Hash Table Performance Optimization",
        "strength": 1.0,
        "reason": "Prime sizing is key optimization technique"
      },
      {
        "id": "urn:wskg:computer-science:collision-resolution:001",
        "title": "Efficient Collision Resolution",
        "strength": 0.95,
        "reason": "Primes enable better collision handling"
      }
    ],
    "skos:narrower": [],
    "related": [
      {
        "id": "urn:wskg:cryptography:rsa:001",
        "type": "related_application",
        "relationship": "Another major CS application of primes"
      },
      {
        "id": "urn:wskg:algorithms:randomization:001",
        "type": "methodology",
        "relationship": "Primes help achieve randomization"
      },
      {
        "id": "urn:wskg:algorithms:string-matching:rabin-karp:001",
        "type": "specific_algorithm",
        "relationship": "Uses prime moduli for rolling hash"
      }
    ],
    "skos:related": [
      {
        "@id": "urn:wskg:algorithms:bloom-filters:001",
        "@type": "skos:Concept",
        "skos:prefLabel": "Bloom Filters",
        "skos:note": "Probabilistic data structure using prime-sized arrays"
      }
    ],
    "conflicts": [],
    "supersedes": []
  },
  "provenance": {
    "prov:wasDerivedFrom": [
      {
        "@id": "urn:source:knuth-taocp-v3",
        "@type": "prov:Entity",
        "dc:title": "The Art of Computer Programming, Volume 3: Sorting and Searching",
        "dc:creator": "Donald E. Knuth",
        "dc:identifier": "ISBN:978-0201896855",
        "dc:type": "textbook",
        "confidence": 1.0
      },
      {
        "@id": "urn:source:cormen-algorithms",
        "@type": "prov:Entity",
        "dc:title": "Introduction to Algorithms",
        "dc:creator": ["Thomas Cormen", "Charles Leiserson", "Ronald Rivest", "Clifford Stein"],
        "dc:identifier": "ISBN:978-0262046305",
        "dc:type": "textbook",
        "confidence": 1.0
      },
      {
        "@id": "urn:source:sedgewick-algorithms",
        "@type": "prov:Entity",
        "dc:title": "Algorithms",
        "dc:creator": ["Robert Sedgewick", "Kevin Wayne"],
        "dc:identifier": "ISBN:978-0321573513",
        "dc:type": "textbook",
        "confidence": 1.0
      }
    ],
    "prov:wasGeneratedBy": {
      "@type": "prov:Activity",
      "prov:used": "expert_knowledge_synthesis",
      "prov:startedAtTime": "2025-12-30T02:28:00.000Z",
      "prov:endedAtTime": "2025-12-30T02:28:00.000Z"
    },
    "dc:creator": [
      "copilot-agent",
      "math-expert",
      "computer-science-expert"
    ],
    "dc:created": "2025-12-30T02:28:00.000Z",
    "dc:modified": "2025-12-30T02:28:00.000Z",
    "sources": [
      {
        "type": "textbook",
        "citation": "Knuth: TAOCP Volume 3 - Sorting and Searching",
        "isbn": "978-0201896855",
        "confidence": 1.0,
        "note": "Authoritative source on hash table design"
      },
      {
        "type": "textbook",
        "citation": "Cormen et al.: Introduction to Algorithms",
        "isbn": "978-0262046305",
        "confidence": 1.0
      },
      {
        "type": "textbook",
        "citation": "Sedgewick & Wayne: Algorithms",
        "isbn": "978-0321573513",
        "confidence": 1.0
      }
    ],
    "extraction_method": "expert_knowledge_synthesis",
    "validation": {
      "validator": "computer_science_expert",
      "date": "2025-12-30",
      "notes": "Hash table and algorithm details verified"
    }
  },
  "pedagogical": {
    "target_audience": [
      "undergraduate_cs_students",
      "software_engineers",
      "data_structure_learners"
    ],
    "estimated_time": "30min",
    "difficulty_curve": 0.5,
    "prerequisites_check": true,
    "learning_objectives": [
      "Understand why prime numbers improve hash table performance",
      "Explain coprimality and its role in collision reduction",
      "Implement prime-sized hash tables",
      "Recognize other CS applications of primes",
      "Appreciate mathematical foundations of data structures"
    ],
    "common_errors": [
      "Using powers of 2 for hash table size (common but not optimal)",
      "Not understanding the connection to coprimality",
      "Thinking primes only matter for cryptography",
      "Ignoring load factor when choosing table size"
    ],
    "teaching_tips": [
      "Demonstrate collision rates: 1000 vs 1009 table size",
      "Visualize key distribution in hash tables",
      "Show concrete performance benchmarks",
      "Connect to modular arithmetic concepts",
      "Discuss real-world libraries: Java HashMap, Python dict"
    ]
  },
  "rendering_hints": {
    "primary_representation": "application_with_code_examples",
    "show_images": true,
    "include_examples": true,
    "visualization": [
      "hash_table_collision_comparison",
      "key_distribution_diagram",
      "performance_benchmark_chart",
      "code_implementation_examples"
    ],
    "emphasis": [
      "coprimality_property",
      "collision_reduction",
      "practical_implementation"
    ]
  }
}
